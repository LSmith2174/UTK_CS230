# UTK_CS230
Computer Structures and Architecture


Code emulates a RISCV machine and the 5 steps of the pipeline: fetch, decode, execute, memory, and writeback. Fetch emulates the pipeline by reading in a file with binary in it and reading 4 bytes at a time, which is the length of each instruction, and stores it in an array. Decode will read source values and sign extend immediate values. Using an opcode map, we can determine what instruction the input is, and break it down by type in order to execute it, which is the next stage of the pipeline. In Execute the emulated machine uses the ALU (Arithmetic Logic Unit) to do the operation needed for the given instruction. The following instructions are supported in this stage: LUI, AUIPC, JAL, JALR, BEQ, BNE, BLT, BGE, LB, LH, LW, LD, LBU, LHU, LWU, SB, SH, SW, SD, ADDI, XORI, ORI, ANDI, SLLI, SRLI, SRAI, ADD, SUB, SLL, XOR, SRL, SRA, OR, AND, ECALL, MUL, DIV, REM. The memory stage builds upon load and store, taking what the ALU did in the execute stage and reading or writing values. This code supports LB, LBU, LH, LHU, LW, LWU, LD as well as SB, SH, SW, and SD. Once the memory() function runs, it tests to see if the instruction is a load or store. Then if a store it uses the function memory_write to take the execute result and the right_val, and puts the right_val into the location given by the execute result. If a load, it uses the function memory_read and gets the value at the location given by the execute result. This is the fourth stage of the pipline and is nearly the completion of this project. The final part of the project, writeback, uses all five stages to take a binary file and output something. For example, the test file outputs "Hello World". The first step is the fetch stage, which fetches the instruction, decode of course decodes the fetched instruction, execute executes that instruction  using the ALU, Memory writes loads and stores to the correct memory address, and this stage, writeback sets the program counter and follows through the instruction. This file mimics a RISC-V machine and the pipeline it's instructions follow. 
